\documentclass{beamer}
\mode<presentation> {\usecolortheme{wolverine}}
\usepackage{textgreek}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{cspsym}
\usepackage{fancyvrb}
\usepackage{natbib}
\usepackage{color}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}


\usepackage{setspace} 
\usepackage{makeidx}
\usepackage{graphicx}

\usepackage{amssymb,amsmath}
\usepackage{fancyvrb}
\usepackage[english]{babel}
\usepackage{natbib}
\usepackage{wrapfig}
\usepackage{ifpdf}
\usepackage{color}
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}

\newcommand{\prefixoperator}{\mathbin{\mathord{\mbox{---}}\mathord{>}}}
\makeindex


\newcommand{\ar}{\rightarrow}
\newcommand{\all}{\forall}
%\newcommand{\binding}{\mathbin{\mathord{>}\hspace{-0.35em}\mathord{>}\hspace{-0.35em}\mathord{=}}}
\newcommand{\binding}{\gg}



\newcommand{\IO}{\mathsf{IO}}
\newcommand{\datarm}{\mathsf{data}}
\newcommand{\wheresf}{\mathsf{where}}
\newcommand{\conssf}{\mathsf{cons}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\zrm}{\mathsf{z}}
\newcommand{\srm}{\mathsf{s}}
\newcommand{\Nbb}{\mathbb{N}}
\newcommand{\Streamsf}{\mathsf{Stream}}
\newcommand{\idsf}{\mathsf{id}}
\newcommand{\Msf}{\mathsf{M}}
\newcommand{\returnsf}{\mathsf{return}}
\newcommand{\record}{\mathsf{record}}
\newcommand{\mutual}{\mathsf{mutual}}
\newcommand{\Size}{\mathsf{Size}}
\newcommand{\coinductive}{\mathsf{coinductive}}
\newcommand{\constructor}{\mathsf{constructor}}
\newcommand{\delay}{\mathsf{delay}}
\newcommand{\field}{\mathsf{field}}
\newcommand{\force}{\mathsf{force}}
\newcommand{\ProcessShape}{\mathsf{ProcessShape}}
\newcommand{\Process}{\mathsf{Process}}
\newcommand{\Processplus}{\mathsf{Process}\mathord{+}}
\newcommand{\Choice}{\mathsf{Choice}}
\newcommand{\Lab}{\mathsf{Lab}}
\newcommand{\ChoiceSet}{\mathsf{ChoiceSet}}
\newcommand{\Label}{\mathsf{Label}}
\newcommand{\node}{\mathsf{node}}
\newcommand{\terminate}{\mathsf{terminate}}


\newcommand{\emptyhat}{\widehat{\emptyset}}
\newcommand{\tophat}{\widehat{\top}}
\newcommand{\efq}{\mathsf{efq}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\Boolhat}{\widehat{\mathsf{Bool}}}
\newcommand{\plushat}{\mathbin{\widehat{+}}}
\newcommand{\IntChoice}{\mathsf{IntChoice}}
\newcommand{\ExtChoice}{\mathsf{ExtChoice}}
\newcommand{\deadlock}{\mathsf{deadlock}}
\newcommand{\fmap}{\mathsf{fmap}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}
\newcommand{\Interrupt}{\mathsf{Interrupt}}
\newcommand{\hhide}{hide}
\newcommand{\Hide}{\mathsf{Hide}}
\newcommand{\ssubset}{\mathsf{subset}}
\newcommand{\projssubset}{\mathsf{projSubset}}

\newcommand{\with}{\mathsf{with}}
\newcommand{\Rename}{\mathsf{Rename}}
\newcommand{\parallelWithIndices}[2]{\mathbin{{}_{#1} \mathord{\parallel}{}_{#2}}}
\newcommand{\ff}{\mathsf{ff}}
\newcommand{\ttsf}{\mathsf{tt}}
\newcommand{\Parallelsf}{\mathsf{Parallel}}
\newcommand{\subsetsf}{\mathsf{subset}}
\newcommand{\Truesf}{\mathsf{True}}
\newcommand{\subsf}{\mathsf{sub}}





%\newcommand{\binding}{\mathbin{\mathord{>}\hspace{-0.35em}\mathord{>}\hspace{-0.35em}\mathord{=}}}







\newcommand{\includeXfigPictexWithoutFigure}[1]{\ifpdf
\begin{center}
\input #1.pdf_t
%\caption{Your figure}
\end{center}\else%
\begin{center}
\input #1.pstex_t
%\caption{Your figure}
\end{center}\fi}




\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}





 \usepackage{amssymb}
 \usepackage{bbm}
 \usepackage[greek,english]{babel}

 \usepackage{ucs}
 \usepackage[utf8x]{inputenc}
 \usepackage{autofe}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Representing the Process Algebra CSP in Type
Theory]{Representing the Process Algebra CSP in Type
Theory} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Bashar Igried and Anton Setzer} % Your name
\institute[Swansea University] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Swansea University, Swansea,Wales, UK \\ % Your institution for the title page
\medskip
\textit{bashar.igried@yahoo.com , a.g.setzer@swansea.ac.uk} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}

% % % % % % % % % % % % % % % % % % % % % % % % % %

%Start document 

% % % % % % % % % % % % % % % % % % % % % % % % % %

\begin{frame}
\titlepage
\end{frame}


% % % % % % % % % % % % % % % % % % % % % % % % % %

%Over View 

% % % % % % % % % % % % % % % % % % % % % % % % % %




\begin{frame}
\frametitle{Overview}
\begin{enumerate}


\item Process Algebra 
\item CSP
\item Theorem Prover Agda (Omitted) 
\item CSP-Agda
\item Choices Set 
\item Why Agda
\item Conclusion
\item Future Work 


\end{enumerate}
\end{frame}





% % % % % % % % % % % % % % % % % % % % % % % % % %

%Over View 

% % % % % % % % % % % % % % % % % % % % % % % % % %


%
%\begin{frame}
%\begin{itemize}
%
%\item Processes in our approach are similar to interactive programs.
%
%\item They are defined using an atomic operation, corresponding to the next transitions they can make. 
%
%\item Since processes can loop they are defined coinductively, for which we will use coinductive record type.
%
%\item Agda as a proof assistant allows to define elements of coalgebraic data types by copattern matching in such a way that they are productive.
%
%
%\end{itemize}
%\end{frame}
%


% % % % % % % % % % % % % % % % % % % % % % % % % %

%Proces Algebra 

% % % % % % % % % % % % % % % % % % % % % % % % % %




\begin{frame}
\frametitle{Overview Of Process Algebra } % Table of contents slide, comment this block out to remove it

\begin{itemize}
\item ``Process algebra'' was initiated in 1982 by Bergstra and Klop \cite{begstraKlop:FixedPointSemantics}, in order to provide a formal semantics to concurrent systems

\end{itemize}

\begin{itemize}
\item Baeten et.al :
 Process algebra is the study of distributed or parallel systems by algebraic means. \\~\\

\end{itemize}



\begin{itemize}
\item three main process algebra theories were developed.

\begin{itemize}

\item Calculus of Communicating Systems (CCS). \\
{\footnotesize developed by Robin Milner in 1980}

\item Communicating Sequential Processes (CSP). \\
{\footnotesize developed by Tony Hoare in 1978  }

\item Algebra of Communicating Processes (ACP). \\
{\footnotesize developed by Jan Bergstra and Jan Willem Klop, in 1982 }

\end{itemize}


\item Processes will be defined according to the operational behaviour of the corresponding CSP process 

\end{itemize}
\end{frame}


%\begin{fra
%\frametitle{Overview Of Process Algebra } % Table of contents slide, comment this block out to remove it
%
%\begin{itemize}
%\item ``Process algebra'' was initiated in 1982 by Bergstra and Klop \cite{begstraKlop:FixedPointSemantics}, in order to provide a formal semantics to concurrent systems
%
%\end{itemize}
%
%\begin{itemize}
%\item Baeten et.al :
% Process algebra is the study of distributed or parallel systems by algebraic means. \\~\\
%\begin{itemize}
%\item The word ‘process’ here refers to behavior of a system.
%\\~\\
%% A system is anything  showing behavior,  such as the
%% execution of a software system, the actions of a machine or even the actions of a human being.
%
%
%%Behavior is the total of events, actions or evolutions that a
%%system can perform, the order in which these can be executed and maybe other aspects of this execution such as timing, probabilities, or continuous  aspects.  
%%Always,  the focus is on certain aspects of behavior, disregarding  other aspects, so an abstraction or idealization of the ‘real’ behavior is considered
%
%%actions are usually thought to be discrete:  occurrence is at some moment in time, and different actions are separated in time.
%
%\item The word ‘algebra’ denotes that the approach in dealing with behavior is algebraic and axiomatic. \\~\\
%
%%A process algebra can be defined as any mathematical structure satisfying the axioms given for the basic operators
%
%\end{itemize}
%\item three main process algebra theories were developed.
%\begin{itemize}
%
%\item Calculus of Communicating Systems (CCS). \\
%{\footnotesize developed by Robin Milner in 1980}
%
%\item Communicating Sequential Processes (CSP). \\
%{\footnotesize developed by Tony Hoare in 1978  }
%
%\item Algebra of Communicating Processes (ACP). \\
%{\footnotesize developed by Jan Bergstra and Jan Willem Klop, in 1982 }
%
%\end{itemize}
%\end{itemize}
%\end{fram
%






% % % % % % % % % % % % % % % % % % % % % % % % % %

%CSP

% % % % % % % % % % % % % % % % % % % % % % % % % %





\begin{frame}
\frametitle {CSP}
\begin{itemize}

\item The process algebra CSP was developed by Hoare in 1978.

\item CSP considered as a formal specification language, developed in order to describe a concurrent systems. \\
{\footnotesize
by identifying their behaviour through their communications.}

\item CSP is a notation for studying processes which interact with each other and their environment.

\item In CSP we can describe a process by the way it can communicate with its environment. 

%The most fundamental object in CSP is an event, We call the set of events in CSP an alphabet, which contains all possible interaction for processes.

\item A system contains one or more processes, where these processes interact with each other through their interfaces. 

\end{itemize}
\end{frame}




% % % % % % % % % % % % % % % % % % % % % % % % % %

%CSP operator

% % % % % % % % % % % % % % % % % % % % % % % % % %






\begin{frame}
\frametitle{CSP Syntax}
\begin{center}
\begin{tabular}{p{2in}p{1.5in}c} 
 Q ::=
  STOP                            & $\ STOP   $           \\%[1ex]
  
 \hspace{25pt}$|$ SKIP            & $\ SKIP    $          \\%[1ex]
  
 \hspace{25pt}$|$ prefix          & $\ a \then Q $        \\%[1ex]
  
 \hspace{25pt}$|$ external choice & $\ Q \extchoice Q $   \\%[1ex]
  
 \hspace{25pt}$|$ internal choice & $\ Q \intchoice Q $   \\%[1ex]
  
 \hspace{25pt}$|$ hiding          & $\ Q \hide a $        \\%[1ex]

 \hspace{25pt}$|$ renaming        & $\ Q[R]      $        \\%[1ex]
  
 \hspace{25pt}$|$ parallel        & $\ Q \parallelWithIndices{X}{Y} Q $    \\
  
 \hspace{25pt}$|$ interleaving    & $\ Q \interleave Q $  \\%[1ex]
  
 \hspace{25pt}$|$ interrupt       & $\ Q \interrupt Q $   \\%[1ex]
  
 \hspace{25pt}$|$ composition     & $\ Q  ; Q $        \\%[1ex]
 
\end{tabular}
\end{center}
\end{frame}






%\begin{frame}
%\frametitle{Theorm prover Agda }
%\begin{itemize}
%
%\item Agda is a dependently typed functional programming language.
%
%\item The current version of this language is Agda2 which has been designed and implemented by Ulf Norell in his PhD in 2007.
%
%
%{\footnotesize Our work in this research  is carried out in the theorem prover Agda version 2.}
%
%
%\end{itemize}
%\begin{itemize}
%
%\item Agda language considered as a functional programming language with numerous features. 
%\begin{itemize}
%\item Total Language
%\begin{enumerate}
%\item Type checking % The Agda type checker refuses any incorrect proofs by detecting unmatched types.
%\item Coverage checking %in order to be sure that the patterns cover all possible cases
%\item Termination checking %Agda is a total language then each program in it must terminate, since Agda without termination checker makes the logic behind this language inconsistent.
%\item Strict positivity of constructors checking 
%\item Guardedness checking in coinductive programs
%%Needless to say, the most interesting challenges in the design of programming language is infinite coinductive data types and define function on them. Guarded corecursion considered as a kind of recursion which allowed arbitrary recursive calls as long as the are guarded by coinductive constructor.
%
%\end{enumerate}
%\item Undoubtedly Agda skilful supports pattern matching,
%\item Inductive Data Type 
%\item Mixfix Operators and Unicode 
%\item Interactive Interface
%
%\end{itemize}
%\end{itemize}
%\end{frame}




% % % % % % % % % % % % % % % % % % % % % % % % % %

%Over View 

% % % % % % % % % % % % % % % % % % % % % % % % % %






\begin{frame}
\frametitle{CSP-Agda}

\begin{itemize}

\item we will represent the process algebra CSP in a coinductive form in dependent type theory.

\item implement it in the Agda

\item CSP processes can proceed at any time both
with labelled transitions and with silent transitions.

\item Therefore, processes in CSP-Agda
have as well this possibility.
%\item  The first ones correspond to external choice and the latter correspond to internal choices.


\end{itemize}
\end{frame}




\begin{frame}
\frametitle{CSP-Agda}

In Agda the corresponding code is as follows: % assuming $\Label: \Set $:

\[\begin{array}[t]{@{}l} 
\record\ \Process\;: \Set\ \wheresf  \\
\mbox{\quad}
\begin{array}[t]{@{}lcl} 
\coinductive \\
\field \\
\mbox{\quad} \begin{array}[t]{@{}l} E \; \; \;\; \; : \; \Choice\\
\begin{array}[t]{@{}cl@{}lcl} 
 Lab  &:& \; \ChoiceSet \;E \ar \Label\\
 PE   &:& \; \ChoiceSet\;E \ar \Process\\
 I    &:&\;  \Choice\\
 PI   &:& \; \ChoiceSet \;I  \ar \Process\\

\end{array} 
\end{array} 
\end{array} 
\end{array} \]


\end{frame}



\begin{frame}
\frametitle{CSP-Agda}


\includeXfigPictexWithoutFigure{exampleProcess}



As an example the following Agda code describe the process pictured below:
\[\begin{array}[t]{@{}l} 
\\
E \; P = \mbox{code for }\{1,2,3\}\mbox{\qquad \quad \quad} I\; P = \mbox{ code for } \{4,5\}\\
\begin{array}[t]{@{}lclclclclcllclclclclclclclcl}
Lab \; P \;1 &=& a&\mbox{\quad} &Lab \;P\;2 &=& b &\mbox{\quad} &Lab\; P\;3 &=& c\\
PE \; P\;1 &=& P_1&\mbox{\quad} &PE \; P\;2 &=& P_2 &\mbox{\quad} &PE\;3 &=& P_3&
\mbox{\quad}& \\
PI\;P\;4 &=& P_4&\mbox{\quad} &PI\;P\;5 &=& P_5
\end{array} \end{array} \]

\end{frame}




\begin{frame}
\frametitle{CSP-Agda}
So we have in case of a process
progressing 
\begin{itemize}

\item an index set E of external choices and for each external choice e a Label (Lab e) and a next process (PE e)

\item an index set of internal
choices I and for each internal choice i a next process (PI i )



\end{itemize}
\end{frame}





%\begin{frame}
%\begin{itemize}
%\item In mathematical notation a process is represented as
%follows (assuming a set of labels $\Label:\Set$):
%\end{itemize}
%
%
%\[\begin{array}[t]{@{}l} 
%\Process = 
%\begin{array}[t]{@{}l@{}l} %\{&\terminate(a) \mid a \in A \}\; \cup\\
%\{&\node \;(E,Lab,PE,I,PI) \mid \begin{array}[t]{@{}l@{\;}c@{\;}ll@{\;}c@{\;}ll@{\;}c@{\;}ll@{\;}c@{\;}l}
%\; E &\in&\Choice,\\&
%Lab &:& E \ar \Label,\\&
%PE  &:& E \ar \Process,\\&
%I   &\in& \Choice,\\&
%PI  &:& \multicolumn{4}{l}{I \ar \Process\ \; \}}
%\end{array} \end{array} \end{array} \]
%
%\end{frame}
%




\begin{frame}
\frametitle{Interleaving operator }

We represent interleaving operator in CSP-Agda as follow

\[\begin{array}[t]{@{}lcl} 
\_|||\_ \; : \;  \Process \; \ar\; \Process \; \ar \; \Process \;  \\
 E \; (P\; |||\; Q) \; \; \; \; \; \; \; \; \; \; \; \; \; \;  \;= \; E\; P\; +'\; E\; Q \\
 Lab \; (P\; |||\; Q)\; (inl\; x)\;  = \;Lab\; P\; x \\
 Lab \; (P\; |||\; Q)\; (inr\; x)\;  = \;Lab\; Q\; x \\
 PE \; (P\;|||\;Q)\; (inl\; x) \; \; = \; PE\; P\;\;x \; ||| \;Q  \\
 PE \; (P\;|||\;Q)\;  \; (inr\; x) \; = P \; ||| \; PE\; Q\;\;x \  \\
 I \; (P\; |||\; Q) \; \; \; \; \;\;  \; \; \; \; \; \; \; \; \; \; \; = \;I\; P\; +' \;I\; Q \\
 PI \; (P\;|||\;Q)\; (inl\; x)  \; \; \; \;  = \; PI\; P\;\;x \; ||| \;Q  \\
 PI \; (P\;|||\;Q)\;  \; (inr\; x)  \; \; \;  = P \; ||| \; PI\; Q \;x \  \\
\end{array} \]


\end{frame}



%
%
%\begin{frame}
%\begin{itemize}
%\item The recursive references to $(\Process\;A)$ are labelled by $\infty$ to indicate that they are indeed coinductive, so infinite (in general non-well-founded) loops are allowed
%
%\end{itemize}
%\end{frame}


\begin{frame}

\[\begin{array}[t]{@{}lcl} 
\datarm Tr  : (l : List Label)\ar (P : \Process ) \ar \Set \;  \wheresf \\
\mbox{\quad} empty : \{ P : \Process \; \} \ar Tr \; [] \; P \\
\mbox{\quad}extchoice : \; \{ P : \Process \; \} \\
\mbox{\quad}\mbox{\quad} \ar  (x : \ChoiceSet (E \; P )) \\
\mbox{\quad}\mbox{\quad} \ar (l : List Label)\\
\mbox{\quad}\mbox{\quad} \ar Tr \; l \; (PE\; P \; x) \\
\mbox{\quad}\mbox{\quad} \ar Tr\; (Lab\; P\; x\; ::\; l)\; P\\
\mbox{\quad}intchoice : \; \{ P : \Process  \} \\
\mbox{\quad}\mbox{\quad} \ar  (x : \ChoiceSet (I  \; P)) \\
\mbox{\quad}\mbox{\quad} \ar (l : List Label)\\
\mbox{\quad}\mbox{\quad} \ar Tr \; l \; (PI\; P\; x) \\
\mbox{\quad}\mbox{\quad} \ar Tr\;l \; P\\

\end{array} \]

\end{frame}


\begin{frame}

\[\begin{array}[t]{@{}lcl} 
\_\refinedby\_ :\; (P\;: \Process \; ) (P'\;: \Process \; )\ar \Set  \\
P \;\refinedby \;P' \; = (l : List \; Label) \ar Tr \; l \; P' \ar Tr \; l \; P\\



\end{array} \]



\end{frame}


\begin{frame}

\frametitle{ Proving Symmetry of Interleaving operator }


\[\begin{array}[t]{@{}lcl} 
Sym||| \; : \; (P\; Q\; :\; \Process) \; \ar\; (P \; ||| \; Q) \; \refinedby \; (Q \; ||| \; P)   \\
 
 Sym|||\;  P\; Q\; empty \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \;  =\; empty \\ 
 Sym|||\; P\; Q\; (extch\; (inl\; x)\; l\; tr)\; =\; extch\; (inr\; x)\; l \; (Sym|||\; P\; (PE\; Q\; x)\; tr) \\
 Sym|||\; P\; Q\; (extch\; (inr\; x)\; l\; tr)\; =\; extch\; (inl\; x)\; l\; (Sym|||\; (PE\; P\; x)\; Q\; tr)\; \\
 Sym|||\; P\; Q\; (intch\; (inl\; x)\; l\; tr)\; \; =\; \; intch\; (inr\; x)\; l\; (Sym|||\; P\; (PI\; Q\; x)\; tr)\; \\
 Sym|||\; P\; Q\; (intch\; (inr\; x)\; l\; tr)\; \; =\; \; intch\; (inl\; x)\; l\; (Sym|||\; (PI\; P\; x)\; Q\; tr) \\
 
\end{array} \]

\end{frame}



\begin{frame}
\frametitle{Choices Set}
\begin{itemize}

\item We needed  to have a set of choices.
\item This is modelled by a universe consisting of a set $\Choice$ of codes for choice sets, and a function
$\ChoiceSet$, which maps a code to the actual choice
set it corresponds to. 

\item Universes go back to Martin-L{\"o}f in order to formulate the notion of a type consisting of types.

\item Universes are defined in Agda by an inductive-recursive definition:
we define inductively the set of codes in the universe while
recursively defining the decoding function.



\end{itemize}
\end{frame}





\begin{frame}
\frametitle{Choices Set}

We give here the code expressing that Choice is closed under $\Bool$, disjoint union $+$ and subset.

%Closure under other sets needed can be easily added as needed
%(the symbols for $\Boolhat$, $\plushat$ will be written as 
%$\Bool'$, $+'$ in actual Agda)


\[\begin{array}[t]{@{}l} 
\mutual\\
\mbox{\quad}
\begin{array}[t]{@{}l} 
\datarm\;\Choice : \Set\ \wheresf\\
\mbox{\quad} \begin{array}[t]{@{}lcl} 
\Boolhat &: & \Choice\\
\_\plushat\_ &:& \Choice \ar \Choice \ar \Choice\\
subset &:& (E : Choice) \ar  (\ChoiceSet E \ar Bool) \ar Choice
\end{array} \end{array} \\
\\
\ChoiceSet : \Choice  \ar \Set \\
\begin{array}[t]{@{}lcl} 
\ChoiceSet\;\Boolhat &=& \Bool\\
\ChoiceSet\;(a \plushat b) &=& 
\ChoiceSet\;a + \ChoiceSet\;b \\
\ChoiceSet\;(subset\; E\; f) &=& subset\; (\ChoiceSet\; E)\; f

\end{array} 
\end{array} 
\]

\end{frame}


\begin{frame}
\frametitle{Why Agda ... }
\begin{itemize}
 
\item Agda supports inductive-recursion. \\ {\footnotesize Induction-Recursion allows us to define our universes}



\item Agda pattern matching resplendent, and its easy in order to pattern match on indexed data type.

\item Agda support light-weght syntax for introducing arguments more than Coq.

\item Agda supports definition of coalgebras by elimination rules and defining elements by pattern and copattern matching

\end{itemize}
\end{frame}





%
%
%\begin{frame}
%\frametitle{Why Agda ... }
%\begin{itemize}
%
%
%
%\item Coq have a lot of features and tactics, \\ {\footnotesize for instance setoid rewrite, the program framework,type classes, omega, etc.} \\
%this tactics and feature are useful in order to write hard proofs in Coq. whereas Agda such features need to write by hand, and this useful to find solutions that fit for some problem domain. In comparison Agda is not tactic-based like Coq.
%
%
%
%\end{itemize}
%\end{frame}
%





%------------------------------------------------

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}

\item For complex examples (e.g recursion) sized types are used to allow application of functions to the co-IH.

\item  A formalisation of CSP in Agda has been developed using coalgebra types and copattern matching.
\item  several laws of CSP have been shown with respect to traces semantics and bisimulation.  
\item Using of copattern matching allowe to define code which it's close to mathematical proof.

\end{itemize}
\end{frame}



\begin{frame}[fragile] 
\frametitle{Further Work }

\begin{itemize}
\item A simulator of CSP processes in Agda has been developed. 
\item define our approach using Sized type 
\end{itemize}

	

\end{frame}



\begin{frame}[fragile] 
\frametitle{Future Work }

\begin{itemize}
\item Looking to the future, we would like to model complex systems in Agda.
\item model examples of processes in ERTMS in Agda 
\item Show corectness. 
\end{itemize}

	

\end{frame}






%------------------------------------------------

\bibliographystyle{abbrv}
\bibliography{TypePresentaion.bib}
%------------------------------------------------

\begin{frame}
\Huge{\centerline{The End}}
\end{frame}


\end{document} 
